@using System.Collections.Immutable
@using Microsoft.Extensions.DependencyInjection
@using Narratoria.Narration
@using Narratoria.Narration.Attachments

@inject IServiceProvider Services
@implements IDisposable

@code {
    [Parameter]
    public Guid SessionId { get; set; } = Guid.NewGuid();

    [Parameter]
    public IReadOnlyList<NarrationStageKind> StageOrder { get; set; } = DefaultStageOrder;

    private static readonly IReadOnlyList<NarrationStageKind> DefaultStageOrder = new[]
    {
        NarrationStageKind.Custom("session_load"),
        NarrationStageKind.Custom("system_prompt_injection"),
        NarrationStageKind.Custom("content_guardian_injection"),
        NarrationStageKind.Custom("attachment_ingestion"),
        NarrationStageKind.Custom("attachment_context_injection"),
        NarrationStageKind.Custom("provider_dispatch"),
        NarrationStageKind.Custom("persist_context")
    };

    [Parameter]
    public IReadOnlyList<string> AllowedContentTypes { get; set; } = new[] { "text/plain", "text/markdown" };

    [Parameter]
    public long MaxBytesPerFile { get; set; } = 4 * 1024 * 1024;

    [Parameter]
    public long MaxBytesTotal { get; set; } = 16 * 1024 * 1024;

    [Parameter]
    public INarrationSessionStore? SessionStore { get; set; }

    [Parameter]
    public INarrationPipelineFactory? PipelineFactory { get; set; }

    [Parameter]
    public IAttachmentUploadStore? UploadStore { get; set; }

    private readonly List<NarrationPipelineTurnView> _turns = new();
    private string _sessionTitle = "Untitled Session";
    private bool _isSubmitting;
    private string? _submissionError;
    private readonly List<AttachmentCandidate> _attachments = new();
    private readonly List<Narratoria.Narration.Attachments.ProcessedAttachment> _processedAttachments = new();
    private StageMetadataProvider? _metadata;
    private CancellationTokenSource? _restoreCts;

    protected override void OnInitialized()
    {
        _metadata = new StageMetadataProvider(StageOrder);

        _restoreCts = new CancellationTokenSource();
        // Fire-and-forget restoration; errors are caught in RestoreAsync to prevent crashes
        _ = RestoreAsync(_restoreCts.Token);
    }

    protected override void OnParametersSet()
    {
        _metadata ??= new StageMetadataProvider(StageOrder);
    }

    public void Dispose()
    {
        _restoreCts?.Dispose();
    }

    private async Task RestoreAsync(CancellationToken cancellationToken)
    {
        try
        {
            var store = SessionStore ?? Services.GetRequiredService<INarrationSessionStore>();
            var context = await store.LoadAsync(SessionId, cancellationToken).ConfigureAwait(false);
            if (context is null)
            {
                var created = await store.CreateSessionAsync(new CreateSessionRequest
                {
                    SessionId = SessionId,
                    Trace = new Narratoria.OpenAi.TraceMetadata(Guid.NewGuid().ToString(), Guid.NewGuid().ToString()),
                    InitialTitle = "Untitled Session"
                }, cancellationToken).ConfigureAwait(false);
                _sessionTitle = created.Title;
            }
            else
            {
                // Optimistic fallback: populate turns from PriorNarration immediately
                if (!context.PriorNarration.IsDefaultOrEmpty)
                {
                    foreach (var line in context.PriorNarration)
                    {
                        var stages = StageOrder.Select(k => new NarrationStageView { Kind = k, Status = NarrationStageStatus.Completed }).ToImmutableArray();
                        _turns.Add(new NarrationPipelineTurnView
                        {
                            TurnId = Guid.NewGuid(),
                            UserPrompt = context.PlayerPrompt,
                            PromptAt = null,
                            Stages = stages,
                            Output = new NarrationOutputView { FinalText = line }
                        });
                    }
                    StateHasChanged();
                }

                // Load existing title via SessionService (non-blocking to turns fallback)
                var svc = Services.GetRequiredService<ISessionService>();
                var title = await svc.GetTitleAsync(SessionId, cancellationToken).ConfigureAwait(false);
                if (!string.IsNullOrWhiteSpace(title))
                {
                    _sessionTitle = title!;
                }
            }

            var persistedTurns = await store.ListTurnsAsync(SessionId, cancellationToken).ConfigureAwait(false);
            if (persistedTurns.Count > 0)
            {
                // Replace any optimistic fallback with persisted turns
                _turns.Clear();
                foreach (var t in persistedTurns)
                {
                    var view = NarrationSessionOrchestratorLogic.FromRecord(t);
                    _turns.Add(view);
                }
                StateHasChanged();
            }

            // Restore processed attachments for display
            try
            {
                var processedStore = Services.GetRequiredService<Narratoria.Narration.Attachments.IProcessedAttachmentStore>();
                var listResult = await processedStore.ListBySessionAsync(SessionId, cancellationToken).ConfigureAwait(false);
                if (listResult.Ok && listResult.Value is { Count: > 0 })
                {
                    _processedAttachments.Clear();
                    _processedAttachments.AddRange(listResult.Value);
                    StateHasChanged();
                }
            }
            catch
            {
                // Non-fatal: attachments display remains empty
            }
        }
        catch
        {
            // Suppress errors during restoration to avoid blocking component initialization
        }
    }

    private async ValueTask SubmitPromptAsync(string prompt, CancellationToken cancellationToken)
    {
        if (_isSubmitting) return;
        _isSubmitting = true;
        _submissionError = null;
        StateHasChanged();

        List<string>? uploadedAttachmentIds = null;
        try
        {
            var turn = NarrationSessionOrchestratorLogic.CreateNewTurn(prompt, StageOrder, expectedAttachmentCount: _attachments.Count);
            _turns.Add(turn);
            StateHasChanged();

            var uploadStore = UploadStore ?? Services.GetRequiredService<IAttachmentUploadStore>();
            var attachmentIds = new List<string>(_attachments.Count);
            uploadedAttachmentIds = attachmentIds;

            try
            {
                foreach (var attachment in _attachments)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    using var content = attachment.OpenReadStream(cancellationToken);
                    var id = await uploadStore.WriteAsync(SessionId, attachment.FileName, attachment.MimeType, attachment.SizeBytes, content, cancellationToken).ConfigureAwait(false);
                    if (string.IsNullOrWhiteSpace(id))
                    {
                        throw new InvalidOperationException("Attachment upload failed: upload store returned an invalid attachment identifier.");
                    }

                    attachmentIds.Add(id);
                }

                if (attachmentIds.Count != _attachments.Count)
                {
                    throw new InvalidOperationException($"Attachment upload failed: expected to upload {_attachments.Count} attachments but only {attachmentIds.Count} succeeded.");
                }
            }
            catch
            {
                foreach (var id in attachmentIds)
                {
                    try
                    {
                        await uploadStore.DeleteAsync(SessionId, id, CancellationToken.None).ConfigureAwait(false);
                    }
                    catch
                    {
                        // best-effort cleanup
                    }
                }

                throw;
            }

            var ctx = new NarrationContext
            {
                SessionId = SessionId,
                PlayerPrompt = prompt,
                PriorNarration = ImmutableArray<string>.Empty,
                WorkingNarration = ImmutableArray<string>.Empty,
                WorkingContextSegments = ImmutableArray<ContextSegment>.Empty,
                Metadata = ImmutableDictionary<string, string>.Empty,
                Trace = new Narratoria.OpenAi.TraceMetadata(Guid.NewGuid().ToString(), Guid.NewGuid().ToString())
            };

            var metadata = _metadata ?? new StageMetadataProvider(StageOrder);
            var scopedMetadata = new TurnScopedStageMetadataProvider(turn.TurnId, metadata);

            // Prepare observer adapter wired to latest turn
            var adapter = new PipelineObserverViewAdapter(
                StageOrder,
                getTurn: _ => _turns[^1],
                setTurn: updated => { _turns[^1] = updated; StateHasChanged(); },
                metadata: scopedMetadata);

            var observer = new TurnScopedObserver(turn.TurnId, adapter);

            var store = SessionStore ?? Services.GetRequiredService<INarrationSessionStore>();
            var existingContext = await store.LoadAsync(SessionId, cancellationToken).ConfigureAwait(false);
            if (existingContext is null)
            {
                _ = await store.CreateSessionAsync(new CreateSessionRequest
                {
                    SessionId = SessionId,
                    Trace = ctx.Trace,
                    InitialTitle = "Untitled Session"
                }, cancellationToken).ConfigureAwait(false);
            }

            var factory = PipelineFactory ?? Services.GetRequiredService<INarrationPipelineFactory>();
            var pipeline = factory.Create(new NarrationPipelineBuildRequest(
                SessionId: SessionId,
                TurnId: turn.TurnId,
                Trace: ctx.Trace,
                StageOrder: StageOrder,
                AttachmentIds: attachmentIds.ToImmutableArray(),
                Observer: observer,
                StageMetadata: scopedMetadata));
            MiddlewareResult result;
            try
            {
                result = await pipeline.RunAsync(ctx, cancellationToken).ConfigureAwait(false);
            }
            catch
            {
                foreach (var id in attachmentIds)
                {
                    try
                    {
                        await uploadStore.DeleteAsync(SessionId, id, CancellationToken.None).ConfigureAwait(false);
                    }
                    catch
                    {
                        // best-effort cleanup
                    }
                }

                throw;
            }

            var allSegments = new List<string>();
            await foreach (var seg in result.StreamedNarration.WithCancellation(cancellationToken))
            {
                allSegments.Add(seg);
                var updated = NarrationSessionOrchestratorLogic.ApplyStreamSegment(_turns[^1], seg);
                _turns[^1] = updated;
                StateHasChanged();
            }

            _ = await result.UpdatedContext.ConfigureAwait(false);
            var finalized = NarrationSessionOrchestratorLogic.FinalizeTurn(_turns[^1], allSegments);
            _turns[^1] = finalized;
            // Persist final turn record for replay
            var snapshots = NarrationSessionOrchestratorLogic.ToSnapshots(finalized.Stages);
            var turnRecord = new NarrationTurnRecord
            {
                SessionId = SessionId,
                TurnId = finalized.TurnId,
                CreatedAt = finalized.PromptAt ?? DateTimeOffset.UtcNow,
                UpdatedAt = DateTimeOffset.UtcNow,
                Prompt = finalized.UserPrompt,
                Outcome = NarrationTurnOutcome.Succeeded,
                StageOrder = finalized.Stages.Select(s => s.Kind.Name).ToImmutableArray(),
                Stages = snapshots,
                OutputSegments = allSegments.ToImmutableArray(),
                IsFinal = true,
                FailureClass = null,
                Trace = ctx.Trace
            };
            await store.UpsertTurnAsync(turnRecord, cancellationToken).ConfigureAwait(false);
            // Refresh processed attachments after ingestion
            try
            {
                var processedStore = Services.GetRequiredService<Narratoria.Narration.Attachments.IProcessedAttachmentStore>();
                var listResult = await processedStore.ListBySessionAsync(SessionId, cancellationToken).ConfigureAwait(false);
                if (listResult.Ok)
                {
                    _processedAttachments.Clear();
                    _processedAttachments.AddRange(listResult.Value ?? Array.Empty<Narratoria.Narration.Attachments.ProcessedAttachment>());
                }
            }
            catch { }
            _attachments.Clear();
            _submissionError = null;
            StateHasChanged();
        }
        catch (OperationCanceledException)
        {
            _submissionError = null;
            try
            {
                var snapshots = NarrationSessionOrchestratorLogic.ToSnapshots(_turns[^1].Stages);
                var canceledRecord = new NarrationTurnRecord
                {
                    SessionId = SessionId,
                    TurnId = _turns[^1].TurnId,
                    CreatedAt = _turns[^1].PromptAt ?? DateTimeOffset.UtcNow,
                    UpdatedAt = DateTimeOffset.UtcNow,
                    Prompt = _turns[^1].UserPrompt,
                    Outcome = NarrationTurnOutcome.Canceled,
                    StageOrder = _turns[^1].Stages.Select(s => s.Kind.Name).ToImmutableArray(),
                    Stages = snapshots,
                    OutputSegments = _turns[^1].Output.StreamedSegments,
                    IsFinal = true,
                    FailureClass = null,
                    Trace = new Narratoria.OpenAi.TraceMetadata(Guid.NewGuid().ToString(), Guid.NewGuid().ToString())
                };
                var store = SessionStore ?? Services.GetRequiredService<INarrationSessionStore>();
                await store.UpsertTurnAsync(canceledRecord, CancellationToken.None).ConfigureAwait(false);
            }
            catch { }
            throw;
        }
        catch (Exception ex)
        {
            _submissionError = "Submission failed. Please try again.";
            StateHasChanged();
            try
            {
                var failureClass = (ex as NarrationPipelineException)?.Error.ErrorClass.ToString() ?? "Unknown";
                var snapshots = NarrationSessionOrchestratorLogic.ToSnapshots(_turns[^1].Stages);
                var failedRecord = new NarrationTurnRecord
                {
                    SessionId = SessionId,
                    TurnId = _turns[^1].TurnId,
                    CreatedAt = _turns[^1].PromptAt ?? DateTimeOffset.UtcNow,
                    UpdatedAt = DateTimeOffset.UtcNow,
                    Prompt = _turns[^1].UserPrompt,
                    Outcome = NarrationTurnOutcome.Failed,
                    StageOrder = _turns[^1].Stages.Select(s => s.Kind.Name).ToImmutableArray(),
                    Stages = snapshots,
                    OutputSegments = _turns[^1].Output.StreamedSegments,
                    IsFinal = true,
                    FailureClass = failureClass,
                    Trace = new Narratoria.OpenAi.TraceMetadata(Guid.NewGuid().ToString(), Guid.NewGuid().ToString())
                };
                var store = SessionStore ?? Services.GetRequiredService<INarrationSessionStore>();
                await store.UpsertTurnAsync(failedRecord, CancellationToken.None).ConfigureAwait(false);
            }
            catch { }
            throw;
        }
        finally
        {
            _isSubmitting = false;
            StateHasChanged();
        }
    }

    private ValueTask AcceptAttachmentsAsync(IReadOnlyList<AttachmentCandidate> files, CancellationToken cancellationToken)
    {
        _attachments.Clear();
        _attachments.AddRange(files);
        return ValueTask.CompletedTask;
    }

    private async Task RenameTitleAsync(CancellationToken cancellationToken)
    {
        var svc = Services.GetRequiredService<ISessionService>();
        var ok = await svc.RenameTitleAsync(SessionId, _sessionTitle, isUserSet: true, cancellationToken).ConfigureAwait(false);
        if (!ok)
        {
            // no-op or validation failure; keep local state unchanged
            return;
        }
    }

    private async Task RemoveAttachmentAsync(string attachmentId)
    {
        if (string.IsNullOrWhiteSpace(attachmentId)) return;

        try
        {
            var processedStore = Services.GetRequiredService<Narratoria.Narration.Attachments.IProcessedAttachmentStore>();
            await processedStore.DeleteAsync(SessionId, attachmentId, CancellationToken.None).ConfigureAwait(false);

            var listResult = await processedStore.ListBySessionAsync(SessionId, CancellationToken.None).ConfigureAwait(false);
            if (listResult.Ok)
            {
                _processedAttachments.Clear();
                _processedAttachments.AddRange(listResult.Value ?? Array.Empty<Narratoria.Narration.Attachments.ProcessedAttachment>());
                StateHasChanged();
            }
        }
        catch
        {
            // best-effort removal; UI will remain unchanged on failure
        }
    }
}

<div class="session-orchestrator">
    <div class="session-title">
        <input value="@_sessionTitle" @oninput="e => _sessionTitle = e.Value?.ToString() ?? _sessionTitle" />
        <button @onclick="() => RenameTitleAsync(CancellationToken.None)">Save title</button>
    </div>
    <AttachmentsDropzone AllowedContentTypes="@AllowedContentTypes" MaxBytesPerFile="@MaxBytesPerFile" MaxBytesTotal="@MaxBytesTotal" OnAccepted="AcceptAttachmentsAsync" />
    @if (_processedAttachments.Count > 0)
    {
        <div class="processed-attachments">
            <h5>Attached</h5>
            <ul>
                @foreach (var a in _processedAttachments)
                {
                    <li>
                        @a.FileName (@a.MimeType) â€” tokens: @a.TokenEstimate@(a.Truncated ? " (truncated)" : string.Empty)
                        <button @onclick="() => RemoveAttachmentAsync(a.AttachmentId)">Remove</button>
                    </li>
                }
            </ul>
        </div>
    }
    <PromptInputBar SubmitPrompt="SubmitPromptAsync" IsSubmitting="@_isSubmitting" />
    @if (!string.IsNullOrWhiteSpace(_submissionError))
    {
        <div class="submission-error" data-testid="orchestrator-error">@_submissionError</div>
    }
    <NarrationPipelineLog Turns="@_turns" StageOrder="@StageOrder" Hovers="@_metadata?.Snapshot()" />
</div>
