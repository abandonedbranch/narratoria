@using System.Collections.Immutable
@using Narratoria.Narration

@inject IServiceProvider Services

@code {
    [Parameter]
    public Guid SessionId { get; set; } = Guid.NewGuid();

    [Parameter]
    public IReadOnlyList<NarrationStageKind> StageOrder { get; set; } = new[]
    {
        NarrationStageKind.Sanitize,
        NarrationStageKind.Context,
        NarrationStageKind.Lore,
        NarrationStageKind.Llm
    };

    [Parameter]
    public IReadOnlyList<string> AllowedContentTypes { get; set; } = new[] { "text/plain", "text/markdown" };

    [Parameter]
    public long MaxBytesPerFile { get; set; } = 4 * 1024 * 1024;

    [Parameter]
    public long MaxBytesTotal { get; set; } = 16 * 1024 * 1024;

    [Parameter]
    public INarrationSessionStore? SessionStore { get; set; }

    [Parameter]
    public NarrationPipelineService? Pipeline { get; set; }

    private List<NarrationPipelineTurnView> _turns = new();
    private bool _isSubmitting;
    private List<AttachmentCandidate> _attachments = new();

    protected override void OnInitialized()
    {
        // Minimal restore omitted for now; orchestrator focuses on new submissions
    }

    private async ValueTask SubmitPromptAsync(string prompt, CancellationToken cancellationToken)
    {
        if (_isSubmitting) return;
        _isSubmitting = true;
        StateHasChanged();

        try
        {
            var turn = NarrationSessionOrchestratorLogic.CreateNewTurn(prompt, StageOrder);
            _turns.Add(turn);
            StateHasChanged();

            var ctx = new NarrationContext
            {
                SessionId = SessionId,
                PlayerPrompt = prompt,
                PriorNarration = ImmutableArray<string>.Empty,
                WorkingNarration = ImmutableArray<string>.Empty,
                WorkingContextSegments = ImmutableArray<ContextSegment>.Empty,
                Metadata = ImmutableDictionary<string, string>.Empty,
                Trace = new Narratoria.OpenAi.TraceMetadata(Guid.NewGuid().ToString(), Guid.NewGuid().ToString())
            };

            var pipeline = Pipeline ?? BuildDefaultPipeline();
            var result = await pipeline.RunAsync(ctx, cancellationToken).ConfigureAwait(false);

            var allSegments = new List<string>();
            await foreach (var seg in result.StreamedNarration.WithCancellation(cancellationToken))
            {
                allSegments.Add(seg);
                var updated = NarrationSessionOrchestratorLogic.ApplyStreamSegment(_turns[^1], seg);
                _turns[^1] = updated;
                StateHasChanged();
            }

            var updatedContext = await result.UpdatedContext.ConfigureAwait(false);
            var finalized = NarrationSessionOrchestratorLogic.FinalizeTurn(_turns[^1], allSegments, StageOrder);
            _turns[^1] = finalized;
            StateHasChanged();
        }
        finally
        {
            _isSubmitting = false;
            StateHasChanged();
        }
    }

    private ValueTask AcceptAttachmentsAsync(IReadOnlyList<AttachmentCandidate> files, CancellationToken cancellationToken)
    {
        _attachments.Clear();
        _attachments.AddRange(files);
        return ValueTask.CompletedTask;
    }

    private NarrationPipelineService BuildDefaultPipeline()
    {
        var provider = new FakeNarrationProvider();
        var middleware = new NarrationMiddleware[]
        {
            new NarrationPersistenceMiddleware(SessionStore ?? new NullSessionStore(), NullNarrationPipelineObserver.Instance).InvokeAsync,
            new ProviderDispatchMiddleware(provider).InvokeAsync
        };
        return new NarrationPipelineService(middleware);
    }

    private sealed class FakeNarrationProvider : INarrationProvider
    {
        public async IAsyncEnumerable<string> StreamNarrationAsync(NarrationContext context, [System.Runtime.CompilerServices.EnumeratorCancellation] CancellationToken cancellationToken)
        {
            var tokens = new[] { "You ", "enter ", "the ", "tavern." };
            foreach (var t in tokens)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Task.Delay(50, cancellationToken);
                yield return t;
            }
        }
    }

    private sealed class NullSessionStore : INarrationSessionStore
    {
        public ValueTask<NarrationContext?> LoadAsync(Guid sessionId, CancellationToken cancellationToken) => ValueTask.FromResult<NarrationContext?>(new NarrationContext
        {
            SessionId = sessionId,
            PlayerPrompt = string.Empty,
            PriorNarration = ImmutableArray<string>.Empty,
            WorkingNarration = ImmutableArray<string>.Empty,
            WorkingContextSegments = ImmutableArray<ContextSegment>.Empty,
            Metadata = ImmutableDictionary<string, string>.Empty,
            Trace = new Narratoria.OpenAi.TraceMetadata(Guid.NewGuid().ToString(), Guid.NewGuid().ToString())
        });

        public ValueTask SaveAsync(NarrationContext context, CancellationToken cancellationToken) => ValueTask.CompletedTask;
    }
}

<div class="session-orchestrator">
    <AttachmentsDropzone AllowedContentTypes="@AllowedContentTypes" MaxBytesPerFile="@MaxBytesPerFile" MaxBytesTotal="@MaxBytesTotal" OnAccepted="AcceptAttachmentsAsync" />
    <PromptInputBar SubmitPrompt="SubmitPromptAsync" IsSubmitting="@_isSubmitting" />
    <NarrationPipelineLog Turns="@_turns" StageOrder="@StageOrder" />
</div>
