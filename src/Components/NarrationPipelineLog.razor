@using System.Collections.Immutable
@using System.Linq
@using System.Text

<div class="narration-log-container">
    @if (_hasValidationError)
    {
        <div class="validation-error" data-testid="validation-error">Invalid stage configuration.</div>
    }
    @if (_hasStreamMismatch)
    {
        <div class="stream-warning" data-testid="stream-warning">Streaming state is not on the latest turn.</div>
    }
    <div class="narration-log">
        @foreach (var turn in Turns)
        {
            <section class="turn" data-turn-id="@turn.TurnId">
                <header class="turn-label">USER</header>
                <div class="user-bubble">@turn.UserPrompt</div>

                <div class="stage-row" role="list">
                    @foreach (var stageKind in StageOrder)
                    {
                        var stageView = FindStage(turn, stageKind);
                        var hover = GetHover(turn.TurnId, stageKind);
                        <span class="chip @GetChipClass(stageView?.Status ?? NarrationStageStatus.Pending)" role="listitem" data-stage="@stageKind.Name" title="@FormatHover(hover)">
                            @stageKind.Name
                        </span>
                    }
                </div>

                <header class="turn-label">NARRATION@(turn.Output.IsStreaming ? " (streaming)" : string.Empty)</header>
                <div class="narration-bubble">@RenderOutput(turn.Output)</div>
            </section>
        }
    </div>
</div>

@code {
    [Parameter]
    public IReadOnlyList<NarrationPipelineTurnView> Turns { get; set; } = Array.Empty<NarrationPipelineTurnView>();

    [Parameter]
    public IReadOnlyList<NarrationStageKind> StageOrder { get; set; } = Array.Empty<NarrationStageKind>();

    [Parameter]
    public IReadOnlyDictionary<(Guid, NarrationStageKind), NarrationStageHover>? Hovers { get; set; }
    private bool _hasValidationError;
    private bool _hasStreamMismatch;

    protected override void OnParametersSet()
    {
        _hasValidationError = !NarrationPipelineLogLogic.IsStageOrderValid(StageOrder) || !NarrationPipelineLogLogic.AreTurnsAligned(StageOrder, Turns);
        _hasStreamMismatch = NarrationPipelineLogLogic.HasStreamMismatch(Turns);
    }

    

    private NarrationStageView? FindStage(NarrationPipelineTurnView turn, NarrationStageKind kind)
    {
        return turn.Stages.FirstOrDefault(s => s.Kind == kind);
    }

    private string RenderOutput(NarrationOutputView output) => NarrationPipelineLogLogic.RenderOutput(output);

    private NarrationStageHover? GetHover(Guid turnId, NarrationStageKind stage)
        => Hovers is null ? null : (Hovers.TryGetValue((turnId, stage), out var hover) ? hover : null);

    private static string FormatHover(NarrationStageHover? hover)
    {
        if (hover is null) return string.Empty;
        var parts = new List<string>(4);
        if (hover.Duration is TimeSpan d) parts.Add($"{d.TotalMilliseconds:F0}ms");
        if (hover.PromptTokens is int pt) parts.Add($"P={pt}");
        if (hover.CompletionTokens is int ct) parts.Add($"C={ct}");
        if (!string.IsNullOrWhiteSpace(hover.Model)) parts.Add(hover.Model!);
        return string.Join(" â€¢ ", parts);
    }

    private string GetChipClass(NarrationStageStatus status) => status switch
    {
        NarrationStageStatus.Pending => "chip pending",
        NarrationStageStatus.Running => "chip running",
        NarrationStageStatus.Completed => "chip completed",
        NarrationStageStatus.Skipped => "chip skipped",
        NarrationStageStatus.Failed => "chip failed",
        _ => "chip"
    };
}
