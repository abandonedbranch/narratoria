@using System

@implements IDisposable

@code {
    [CascadingParameter] internal DockLayout? Layout { get; set; }

    [Parameter] public DockSide Side { get; set; } = DockSide.Center;
    [Parameter] public double? Size { get; set; }
    [Parameter] public string? Class { get; set; }
    [Parameter] public string? Style { get; set; }
    [Parameter] public RenderFragment? ChildContent { get; set; }
    [Parameter(CaptureUnmatchedValues = true)] public Dictionary<string, object>? AdditionalAttributes { get; set; }

    private DockLayout.DockRegistration? _registration;
    private DockSide _currentSide;
    private double? _currentSize;
    private string? _currentClass;
    private string? _currentStyle;
    private RenderFragment? _currentContent;
    private IReadOnlyDictionary<string, object>? _currentAdditionalAttributes;

    protected override void OnInitialized()
    {
        if (Layout is null)
        {
            throw new InvalidOperationException($"{nameof(DockSection)} must be used inside a {nameof(DockLayout)}.");
        }

        _registration = Layout.RegisterSection();
        UpdateRegistration(force: true);
    }

    protected override void OnParametersSet()
    {
        if (_registration is null && Layout is not null)
        {
            _registration = Layout.RegisterSection();
            UpdateRegistration(force: true);
            return;
        }

        UpdateRegistration();
    }

    private void UpdateRegistration(bool force = false)
    {
        if (_registration is null)
        {
            return;
        }

        var attributes = FilterAdditionalAttributes(AdditionalAttributes);
        var changed = force;

        if (force || _currentSide != Side)
        {
            _currentSide = Side;
            _registration.Side = Side;
            changed = true;
        }

        if (force || _currentSize != Size)
        {
            _currentSize = Size;
            _registration.Size = Size;
            changed = true;
        }

        if (!ReferenceEquals(_currentContent, ChildContent))
        {
            _currentContent = ChildContent;
            _registration.ChildContent = ChildContent;
        }

        if (force || !string.Equals(_currentClass, Class, StringComparison.Ordinal))
        {
            _currentClass = Class;
            _registration.Class = Class;
            changed = true;
        }

        if (force || !string.Equals(_currentStyle, Style, StringComparison.Ordinal))
        {
            _currentStyle = Style;
            _registration.Style = Style;
            changed = true;
        }

        if (force || !ReferenceEquals(_currentAdditionalAttributes, attributes))
        {
            _currentAdditionalAttributes = attributes;
            _registration.AdditionalAttributes = attributes;
            changed = true;
        }

        if (changed)
        {
            Layout?.NotifySectionsChanged();
        }
    }

    private static IReadOnlyDictionary<string, object>? FilterAdditionalAttributes(Dictionary<string, object>? attributes)
    {
        if (attributes is null || attributes.Count == 0)
        {
            return null;
        }

        var hasFilteredKeys = false;
        foreach (var key in attributes.Keys)
        {
            if (string.Equals(key, "class", StringComparison.OrdinalIgnoreCase) ||
                string.Equals(key, "style", StringComparison.OrdinalIgnoreCase))
            {
                hasFilteredKeys = true;
                break;
            }
        }

        if (!hasFilteredKeys)
        {
            return attributes;
        }

        var filtered = new Dictionary<string, object>(attributes.Count, StringComparer.OrdinalIgnoreCase);
        foreach (var kvp in attributes)
        {
            if (string.Equals(kvp.Key, "class", StringComparison.OrdinalIgnoreCase) ||
                string.Equals(kvp.Key, "style", StringComparison.OrdinalIgnoreCase))
            {
                continue;
            }

            filtered[kvp.Key] = kvp.Value;
        }

        return filtered;
    }

    public void Dispose()
    {
        if (_registration is not null)
        {
            Layout?.UnregisterSection(_registration);
        }
    }
}
