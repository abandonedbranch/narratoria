@using System.Collections.ObjectModel
@using System.Collections.Specialized
@using System.Text.RegularExpressions
@using Microsoft.JSInterop

@inject IJSRuntime JS

@implements IDisposable
@implements IAsyncDisposable

<div class="chat-scrollback" @ref="_scrollContainer">
    @foreach (var item in _items)
    {
        <div class="chat-item @item.CssClass" @key="item.Key">
            @if (item.Type == ChatItemType.Message)
            {
                <header class="chat-meta">
                    <span class="chat-author">@item.Author</span>
                </header>
                <MarkdownRenderer Content="@item.Content" CssClass="chat-message" />
            }
            else if (item.Type == ChatItemType.Component)
            {
                <header class="chat-meta">
                    <span class="chat-author">@item.Author</span>
                    <span class="chat-command">@item.CommandLabel</span>
                </header>
                <div class="chat-component">
                    @item.ComponentFragment
                </div>
            }
        </div>
    }
</div>

@code {
    private static readonly Regex CommandPattern = new(@"@(?<command>[A-Za-z][\w-]*)", RegexOptions.Compiled);

    [Parameter] public IReadOnlyList<ChatMessage> Messages { get; set; } = Array.Empty<ChatMessage>();

    private readonly ObservableCollection<ChatItem> _items = new();
    private bool _suppressCollectionChanged;
    private bool _isDisposed;
    private bool _shouldScroll;
    private ElementReference _scrollContainer;
    private IJSObjectReference? _scrollModule;

    protected override void OnInitialized()
    {
        _items.CollectionChanged += HandleItemsChanged;
    }

    protected override void OnParametersSet()
    {
        BuildItems();
        _shouldScroll = true;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_shouldScroll && !_isDisposed)
        {
            _shouldScroll = false;
            await ScrollToBottomAsync(smooth: !firstRender);
        }
    }

    private void BuildItems()
    {
        _suppressCollectionChanged = true;
        try
        {
            _items.Clear();

            for (var messageIndex = 0; messageIndex < Messages.Count; messageIndex++)
            {
                var message = Messages[messageIndex];
                var content = message.Content ?? string.Empty;
            var cursor = 0;
            var segmentIndex = 0;
            var commandIndex = 0;

            while (cursor < content.Length)
            {
                var match = CommandPattern.Match(content, cursor);
                if (!match.Success)
                {
                    var remainder = content[cursor..];
                    if (!string.IsNullOrWhiteSpace(remainder))
                    {
                        AddMessageSegment(message.Author, remainder, messageIndex, segmentIndex++);
                    }
                    break;
                }

                var matchIndex = match.Index;
                var isEscaped = matchIndex > 0 && content[matchIndex - 1] == '\\';

                if (isEscaped)
                {
                    var escapeIndex = matchIndex - 1;
                    if (escapeIndex > cursor)
                    {
                        var preEscape = content[cursor..escapeIndex];
                        if (!string.IsNullOrWhiteSpace(preEscape))
                        {
                            AddMessageSegment(message.Author, preEscape, messageIndex, segmentIndex++);
                        }
                    }

                    var literal = content.Substring(matchIndex, match.Length);
                    if (!string.IsNullOrWhiteSpace(literal))
                    {
                        AddMessageSegment(message.Author, literal, messageIndex, segmentIndex++);
                    }

                    cursor = matchIndex + match.Length;
                    continue;
                }

                if (matchIndex > cursor)
                {
                    var preceding = content[cursor..matchIndex];
                    if (!string.IsNullOrWhiteSpace(preceding))
                    {
                        AddMessageSegment(message.Author, preceding, messageIndex, segmentIndex++);
                    }
                }

                var commandName = match.Groups["command"].Value;
                var normalizedToken = ChatCommandRegistry.NormalizeToken(commandName);

                if (!string.IsNullOrEmpty(normalizedToken))
                {
                    var fragment = ChatCommandRegistry.TryCreateFragment(normalizedToken) ?? CreateUnknownFragment(normalizedToken);
                    _items.Add(ChatItem.ForComponent(message.Author, normalizedToken, normalizedToken, fragment, messageIndex, commandIndex++));
                }

                cursor = matchIndex + match.Length;
            }
            }
        }
        finally
        {
            _suppressCollectionChanged = false;
        }
    }

    private void AddMessageSegment(string author, string markdown, int messageIndex, int segmentIndex)
    {
        if (string.IsNullOrWhiteSpace(markdown))
        {
            return;
        }

        _items.Add(ChatItem.ForMessage(author, markdown, messageIndex, segmentIndex));
    }

    private static RenderFragment CreateUnknownFragment(string token)
    {
        return builder =>
        {
            builder.OpenElement(0, "div");
            builder.AddAttribute(1, "class", "unknown-command");
            builder.AddContent(2, $"Unknown command @{token}");
            builder.CloseElement();
        };
    }

    public sealed record ChatMessage(string Author, string Content);

    private void HandleItemsChanged(object? sender, NotifyCollectionChangedEventArgs e)
    {
        if (_suppressCollectionChanged || _isDisposed)
        {
            return;
        }

        _shouldScroll = true;
        _ = InvokeAsync(StateHasChanged);
    }

    void IDisposable.Dispose()
    {
        if (_isDisposed)
        {
            return;
        }

        _isDisposed = true;
        _items.CollectionChanged -= HandleItemsChanged;
    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        ((IDisposable)this).Dispose();

        if (_scrollModule is not null)
        {
            try
            {
                await _scrollModule.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
                // Server disconnected before JS cleanup; safe to ignore.
            }
        }
    }

    private enum ChatItemType
    {
        Message,
        Component
    }

    private sealed class ChatItem
    {
        private ChatItem(ChatItemType type)
        {
            Type = type;
        }

        public ChatItemType Type { get; }
        public string Key { get; init; } = Guid.NewGuid().ToString("N");
        public string Author { get; init; } = string.Empty;
        public string? Content { get; init; }
        public RenderFragment? ComponentFragment { get; init; }
        public string CommandLabel { get; init; } = string.Empty;

        public string CssClass => Type == ChatItemType.Component ? "chat-item-component" : "chat-item-message";

        public static ChatItem ForMessage(string author, string content, int messageIndex, int segmentIndex)
        {
            return new ChatItem(ChatItemType.Message)
            {
                Author = author,
                Content = content,
                Key = $"msg-{messageIndex}-{segmentIndex}"
            };
        }

        public static ChatItem ForComponent(string author, string originalToken, string normalizedToken, RenderFragment fragment, int messageIndex, int commandIndex)
        {
            return new ChatItem(ChatItemType.Component)
            {
                Author = author,
                ComponentFragment = fragment,
                CommandLabel = $"@{originalToken}",
                Key = $"cmd-{messageIndex}-{commandIndex}-{normalizedToken.ToLowerInvariant()}"
            };
        }
    }

    private async Task ScrollToBottomAsync(bool smooth)
    {
        if (_scrollContainer.Equals(default))
        {
            return;
        }

        try
        {
            _scrollModule ??= await JS.InvokeAsync<IJSObjectReference>("import", "./js/chatScrollback.js");
            await _scrollModule.InvokeVoidAsync("scrollToBottom", _scrollContainer, smooth);
        }
        catch (JSDisconnectedException)
        {
            // Circuit ended; ignore scrolling.
        }
    }
}
