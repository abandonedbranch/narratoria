@using System.Collections.ObjectModel
@using System.Collections.Specialized
@using Microsoft.JSInterop

@inject IJSRuntime JS

@implements IDisposable
@implements IAsyncDisposable

<div class="chat-scrollback" @ref="_scrollContainer">
    @foreach (var item in _items)
    {
        <div class="chat-item chat-item-message" @key="item.Key">
            <header class="chat-meta">
                <span class="chat-author">@item.Author</span>
            </header>
            <MarkdownRenderer Content="@item.Content" CssClass="chat-message" />
            <ChatMessageActions MessageId="@item.Id" OnDelete="@HandleDeleteMessageAsync" />
        </div>
    }
</div>

@code {
    [Parameter] public IReadOnlyList<ChatMessage> Messages { get; set; } = Array.Empty<ChatMessage>();
    [Parameter] public EventCallback<string> OnDeleteMessage { get; set; }

    private readonly ObservableCollection<ChatItem> _items = new();
    private bool _suppressCollectionChanged;
    private bool _isDisposed;
    private bool _shouldScroll;
    private ElementReference _scrollContainer;
    private IJSObjectReference? _scrollModule;

    protected override void OnInitialized()
    {
        _items.CollectionChanged += HandleItemsChanged;
    }

    protected override void OnParametersSet()
    {
        BuildItems();
        _shouldScroll = true;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_shouldScroll && !_isDisposed)
        {
            _shouldScroll = false;
            await ScrollToBottomAsync(smooth: !firstRender);
        }
    }

    private void BuildItems()
    {
        _suppressCollectionChanged = true;
        try
        {
            _items.Clear();

            for (var messageIndex = 0; messageIndex < Messages.Count; messageIndex++)
            {
                var message = Messages[messageIndex];
                var content = message.Content ?? string.Empty;
                if (!string.IsNullOrWhiteSpace(content))
                {
                    _items.Add(ChatItem.ForMessage(message.Id, message.Author, content, messageIndex, 0));
                }
            }
        }
        finally
        {
            _suppressCollectionChanged = false;
        }
    }

    public sealed record ChatMessage(string Id, string Author, string Content);

    private void HandleItemsChanged(object? sender, NotifyCollectionChangedEventArgs e)
    {
        if (_suppressCollectionChanged || _isDisposed)
        {
            return;
        }

        _shouldScroll = true;
        _ = InvokeAsync(StateHasChanged);
    }

    void IDisposable.Dispose()
    {
        if (_isDisposed)
        {
            return;
        }

        _isDisposed = true;
        _items.CollectionChanged -= HandleItemsChanged;
    }

    async ValueTask IAsyncDisposable.DisposeAsync()
    {
        ((IDisposable)this).Dispose();

        if (_scrollModule is not null)
        {
            try
            {
                await _scrollModule.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
                // Server disconnected before JS cleanup; safe to ignore.
            }
        }
    }

    private async Task HandleDeleteMessageAsync(string messageId)
    {
        if (string.IsNullOrWhiteSpace(messageId))
        {
            return;
        }

        if (OnDeleteMessage.HasDelegate)
        {
            await OnDeleteMessage.InvokeAsync(messageId);
        }
    }

    private sealed class ChatItem
    {
        public string Id { get; init; } = string.Empty;
        public string Key { get; init; } = Guid.NewGuid().ToString("N");
        public string Author { get; init; } = string.Empty;
        public string? Content { get; init; }

        public static ChatItem ForMessage(string id, string author, string content, int messageIndex, int segmentIndex)
        {
            return new ChatItem
            {
                Id = id,
                Author = author,
                Content = content,
                Key = string.IsNullOrWhiteSpace(id)
                    ? $"msg-{messageIndex}-{segmentIndex}"
                    : id
            };
        }
    }

    private async Task ScrollToBottomAsync(bool smooth)
    {
        if (_scrollContainer.Equals(default))
        {
            return;
        }

        try
        {
            _scrollModule ??= await JS.InvokeAsync<IJSObjectReference>("import", "./js/chatScrollback.js");
            await _scrollModule.InvokeVoidAsync("scrollToBottom", _scrollContainer, smooth);
        }
        catch (JSDisconnectedException)
        {
            // Circuit ended; ignore scrolling.
        }
    }
}
