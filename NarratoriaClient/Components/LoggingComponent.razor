@using Microsoft.Extensions.Logging
@implements IChatCommandComponent
@implements IDisposable
@inject ILogBuffer LogBuffer

<section class="log-panel">
    <header class="log-panel__header">
        <h3>Runtime logs</h3>
        <p>@FormatSummary()</p>
    </header>

    @if (_entries.Count == 0)
    {
        <p class="log-panel__empty">No logs collected yet.</p>
    }
    else
    {
        <div class="log-panel__entries">
            @foreach (var entry in _entries)
            {
                <article class="log-entry @GetLevelClass(entry.Level)">
                    <header>
                        <span class="log-entry__timestamp">@entry.Timestamp.ToLocalTime().ToString("u")</span>
                        <span class="log-entry__level">@entry.Level</span>
                        <span class="log-entry__category">@entry.Category</span>
                    </header>
                    <div class="log-entry__message">@entry.Message</div>
                    @if (entry.Metadata.Count > 0)
                    {
                        <dl class="log-entry__metadata">
                            @foreach (var pair in entry.Metadata)
                            {
                                <dt>@pair.Key</dt>
                                <dd>@FormatValue(pair.Value)</dd>
                            }
                        </dl>
                    }
                </article>
            }
        </div>
    }
</section>

@code {
    private IReadOnlyList<LogEntry> _entries = Array.Empty<LogEntry>();
    private bool _disposed;

    public string CommandToken => "logs";
    public string DisplayName => "Runtime Logs";
    public string Description => "Inspect Narratoria's internal diagnostics.";

    protected override void OnInitialized()
    {
        _entries = LogBuffer.GetEntries();
        LogBuffer.EntriesChanged += HandleEntriesChanged;
    }

    private void HandleEntriesChanged(object? sender, EventArgs e)
    {
        if (_disposed)
        {
            return;
        }

        _ = InvokeAsync(() =>
        {
            _entries = LogBuffer.GetEntries();
            StateHasChanged();
        });
    }

    private string FormatSummary()
    {
        if (_entries.Count == 0)
        {
            return "Waiting for the first log entry.";
        }

        var first = _entries.First().Timestamp.ToLocalTime().ToString("u");
        return $"{_entries.Count} entr{(_entries.Count == 1 ? "y" : "ies")} since {first}";
    }

    private static string GetLevelClass(LogLevel level)
    {
        return level switch
        {
            LogLevel.Trace or LogLevel.Debug => "log-entry--debug",
            LogLevel.Information => "log-entry--info",
            LogLevel.Warning => "log-entry--warn",
            LogLevel.Error or LogLevel.Critical => "log-entry--error",
            _ => "log-entry--info"
        };
    }

    private static string FormatValue(object? value)
    {
        return value switch
        {
            null => "(null)",
            DateTimeOffset dto => dto.ToString("u"),
            DateTime dt => dt.ToString("u"),
            _ => value.ToString() ?? string.Empty
        };
    }

    public void Dispose()
    {
        if (_disposed)
        {
            return;
        }

        _disposed = true;
        LogBuffer.EntriesChanged -= HandleEntriesChanged;
    }
}
