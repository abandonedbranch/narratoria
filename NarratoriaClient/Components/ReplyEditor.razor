@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.JSInterop
@implements IAsyncDisposable

<EditForm Model="_model" OnValidSubmit="HandleSubmit" class="reply-editor">
    <ValidationSummary />
    <div class="input-row">
        <textarea class="message-input"
                  @bind="_model.Message"
                  @bind:event="oninput"
                  placeholder="@PlaceholderText"
                  rows="2"
                  @ref="_textAreaRef"></textarea>
        <button type="submit" disabled="@_isSubmitting">Send</button>
    </div>
</EditForm>

@code {
    [Inject] private IJSRuntime JS { get; set; } = default!;

    [Parameter] public EventCallback<string> OnSend { get; set; }

    private const string PlaceholderText = "Use @help for help, or type your move here for the narrator to progress the session.";
    private readonly ReplyModel _model = new();
    private bool _isSubmitting;
    private ElementReference _textAreaRef;
    private IJSObjectReference? _module;
    private IJSObjectReference? _listenerHandle;
    private DotNetObjectReference<ReplyEditor>? _dotNetRef;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender)
        {
            return;
        }

        _module ??= await JS.InvokeAsync<IJSObjectReference>("import", "./js/replyEditor.js");
        _dotNetRef ??= DotNetObjectReference.Create(this);
        _listenerHandle = await _module.InvokeAsync<IJSObjectReference>("attachReplyEditor", _textAreaRef, _dotNetRef);
    }

    private async Task HandleSubmit()
    {
        if (string.IsNullOrWhiteSpace(_model.Message))
        {
            return;
        }

        _isSubmitting = true;
        try
        {
            var payload = _model.Message;
            _model.Message = string.Empty;
            await InvokeAsync(StateHasChanged);

            if (OnSend.HasDelegate)
            {
                await OnSend.InvokeAsync(payload);
            }
        }
        finally
        {
            _isSubmitting = false;
        }
    }

    [JSInvokable]
    public Task SubmitFromKeyboardAsync()
    {
        return InvokeAsync(HandleSubmit);
    }

    public async ValueTask DisposeAsync()
    {
        if (_listenerHandle is not null)
        {
            try
            {
                await _listenerHandle.InvokeVoidAsync("dispose");
            }
            catch (JSDisconnectedException)
            {
                // Circuit ended; nothing to clean up.
            }
        }

        if (_module is not null)
        {
            try
            {
                await _module.DisposeAsync();
            }
            catch (JSDisconnectedException)
            {
                // Circuit ended before JS cleanup; safe to ignore.
            }
        }

        _dotNetRef?.Dispose();
    }

    private sealed class ReplyModel
    {
        public string Message { get; set; } = string.Empty;
    }
}
