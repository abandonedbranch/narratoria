# Feature Specification: Campaign Format

**Feature Branch**: `007-campaign-format`
**Created**: 2026-02-02
**Status**: Draft
**Input**: User description: "Define the campaign directory structure and manifest schema for Narratoria story packages"

## Prerequisites

**Read first:**
1. [Spec 001 - Tool Protocol](../001-tool-protocol-spec/spec.md) - Understand asset handling
2. [Spec 006 - Skill State Persistence](../006-skill-state-persistence/spec.md) - Understand how lore is semantically indexed (FR-132a: lore chunks stored with embeddings)

**Key relationships**: 
- **Spec 007 and 008 are complementary**:
  - Spec 007 defines the **static** campaign package structure (directory layout, manifest, content files)
  - Spec 008 defines the **dynamic** execution of campaigns (scene loop, memory retrieval, choice generation)
  - **Connection**: Campaign content from Spec 007 (lore files, NPC profiles, plot beats) is ingested into Spec 006 persistence layer and used by Spec 008 scene execution
  - **Reading order**: Understand Spec 007 (what's in a campaign), then Spec 008 (how it's used during play)

**How specs connect**:
- Spec 007 lore files → Spec 006 ingestion (lore chunked and embedded per FR-132a)
- Spec 007 NPC profiles + plot beats → Spec 008 retrieval (semantic search for context)
- Spec 007 assets → Spec 001 asset events → displayed during play

---

## Overview

The Campaign Format defines how story authors package their narratives for Narratoria. A campaign is a self-contained directory containing world-building, characters, plot structure, lore, and creative assets. The directory structure itself serves as the ingestion interface for the ObjectBox vector database, enabling semantic indexing of all campaign content. The AI "hydrates" the campaign based on its completeness—filling gaps intelligently when content is sparse, or executing faithfully when content is detailed.

**Core Principle**: The more a campaign provides, the less the AI invents. This is a spectrum, not a toggle.

**Asset Integration**: Campaign `art/` and `music/` directories are automatically discovered and indexed alongside prose content, enabling contextual asset retrieval during gameplay.

---

## Campaign Format Creeds

Every campaign includes a `README.md` that encodes the following principles:

1. **Respect Human Artistry**: Generated content is a tool to accelerate creative work, never to replace human authorship. Human artists retain creative control.
2. **Radical Transparency**: All AI-generated assets are explicitly marked with a `generated` keyword in their metadata. Authors always know what was human-created vs. machine-created.
3. **Human Override**: Authors can refine, replace, or delete any AI-generated content at any time. Generated content exists to serve the author's vision.
4. **Attribution and Credit**: When campaigns are shared, generated content sources are disclosed (e.g., "NPCs generated by Ollama Gemma 2B on 2026-02-03").
5. **Preserve Intent**: When bootstrapping from sparse data, the LLM prioritizes staying true to the author's explicit input over creative elaboration.

These creeds are the foundation of ethical AI-assisted authorship in Narratoria. They prevent the system from becoming a "creative substitute" and instead position it as a "creative accelerator."

---

## User Scenarios & Testing *(mandatory)*

### User Story 1 - Load and Play a Campaign (Priority: P1)

A player downloads a campaign package and loads it into Narratoria. The system validates the package structure, indexes lore content for semantic search, and presents the story premise. The player can begin playing immediately with contextually relevant choices.

**Why this priority**: This is the fundamental use case—without loading campaigns, nothing else works. It delivers the core value proposition of AI-driven storytelling.

**Independent Test**: Can be fully tested by providing a minimal campaign (just `manifest.json` + `world/setting.md`) and verifying the AI generates appropriate narrative and choices.

**Acceptance Scenarios**:

1. **Given** a valid campaign directory with manifest, **When** the player loads the campaign, **Then** the system displays the story title, setting summary, and initial scene.
2. **Given** a campaign with lore files, **When** the player loads the campaign, **Then** lore content is indexed for semantic retrieval during gameplay.
3. **Given** a campaign missing required files, **When** the player attempts to load it, **Then** the system displays a clear error identifying missing components.
4. **Given** an asset file with a corresponding `.keywords.txt` sidecar, **When** ingestion runs, **Then** the system uses sidecar keywords instead of auto-extraction and marks the asset with human-authored metadata.

---

### User Story 2 - Author Creates a Minimal Campaign (Priority: P1)

A story author creates a campaign with just a premise and basic setting description. The AI fills all gaps (characters, plot beats, locations) through improvisation, creating an emergent narrative experience.

**Why this priority**: Low barrier to entry enables rapid prototyping and encourages experimentation. Authors can start with a single idea and let the AI expand it.

**Independent Test**: Create a campaign with only `manifest.json`, `world/setting.md`, and `plot/premise.md`. Verify the AI generates coherent NPCs, locations, and story progression without explicit definitions.

**Acceptance Scenarios**:

1. **Given** a campaign with only setting and premise, **When** gameplay begins, **Then** the AI invents appropriate NPCs based on setting tone.
2. **Given** no explicit rules system, **When** a mechanical challenge arises, **Then** the AI uses the default rules-light system (2d6 + modifiers).
3. **Given** no character constraints, **When** the player creates a character, **Then** the AI suggests options appropriate to the setting.

---

### User Story 2b - Bootstrap Campaign from Sparse Data (Priority: P2)

An author provides a single piece of seed data (e.g., `premise.txt` containing "I am bread") or a campaign folder with minimal content. Narratoria's on-device LLM enriches the sparse data by generating a complete campaign structure: world setting, NPCs, plot beats, and lore. All generated assets are marked with the `generated` keyword, respecting the campaign format creeds.

**Why this priority**: Lowers the barrier to entry for non-technical authors and enables rapid prototyping. Authors can validate the AI's generated assumptions and refine them iteratively.

**Independent Test**: Create a campaign directory containing only `campaign.md` with "I am a bread elemental in a whimsical bakery." Run ingestion and verify the system generates:
- `world/setting.md` (bakery world details)
- `characters/npcs/` (at least 2-3 NPCs)
- `plot/premise.md` and `plot/beats.json`
- `lore/` (world lore entries)

All generated files MUST contain metadata marking them as `generated: true`.

**Acceptance Scenarios**:

1. **Given** minimal seed data, **When** ingestion runs, **Then** a playable campaign structure is generated within 10 seconds.
2. **Given** generated campaign assets, **When** the author reviews the campaign, **Then** each asset clearly indicates it was AI-generated.
3. **Given** generated assets, **When** the author adds their own NPC definition, **Then** the system does not override it with regenerated content.
4. **Given** sparse input, **When** the LLM generates content, **Then** it respects the author's explicit intent (e.g., "bread elemental" is never replaced with "human warrior").

---

### User Story 3 - Author Creates a Detailed Campaign (Priority: P2)

A story author creates a comprehensive campaign with defined NPCs, plot beats, world constraints, and endings. The AI executes the campaign faithfully, hitting defined beats while maintaining player agency between them.

**Why this priority**: Enables professional-quality interactive fiction with intentional design. Authors who invest time get precise results.

**Independent Test**: Create a campaign with defined NPCs, plot beats, and endings. Verify the AI uses provided character voices, respects constraints, and guides toward defined endings.

**Acceptance Scenarios**:

1. **Given** defined NPC profiles, **When** that NPC speaks, **Then** dialogue matches their personality, motivations, and speech patterns.
2. **Given** defined plot beats, **When** story conditions align, **Then** the AI triggers the appropriate beat.
3. **Given** world constraints (e.g., "magic is rare"), **When** generating content, **Then** the AI respects those constraints.
4. **Given** defined endings, **When** player choices lead toward an ending, **Then** the AI subtly steers toward that conclusion.

---

### User Story 4 - Campaign with Creative Assets (Priority: P3)

A story author includes character portraits, scene backgrounds, ambient music, and combat themes in their campaign. Narratoria ingests these assets into the vector database and surfaces them at contextually appropriate moments during gameplay.

**Why this priority**: Rich media enhances immersion but is optional. Core narrative works without assets.

**Independent Test**: Create a campaign with `art/` and `music/` directories containing images and audio files. Verify assets are ingested into ObjectBox and linked to campaign content.

**Acceptance Scenarios**:

1. **Given** an image file in `art/characters/npc_wizard.png` and an NPC named "wizard", **When** that NPC appears, **Then** the system retrieves and displays the portrait.
2. **Given** audio files in `music/ambient/` and `music/combat/`, **When** gameplay transitions scenes, **Then** appropriate ambient or combat music can be queued.
3. **Given** missing asset files, **When** loading the campaign, **Then** the system gracefully degrades without crashing and logs a warning.

---

### Edge Cases

- What happens when a campaign has circular NPC relationships (A → B → C → A)?
  - System should handle cycles gracefully and use them for narrative tension.
- How does the system handle conflicting constraints (e.g., "magic is common" in setting.md but "magic is forbidden" in constraints.md)?
  - Constraints take precedence; system warns author about conflicts.
- What happens when plot beats become unreachable due to player choices?
  - AI adapts by skipping unreachable beats and improvising toward available endings.
- How does the system handle very large campaigns (1000+ lore files)?
  - Lore is indexed incrementally; semantic search limits context window size.
- What happens when a `.keywords.txt` sidecar file exists but is empty or contains only comments?
  - System falls back to auto-extraction and logs a warning about the empty sidecar file.
- What happens when an author adds a `.keywords.txt` file after initial ingestion?
  - On next campaign reload/re-ingestion, the system replaces auto-extracted keywords with sidecar keywords and updates the ObjectBox entry.

---

## Requirements *(mandatory)*

### Functional Requirements

#### Campaign Structure

- **FR-001**: System MUST recognize a campaign as a directory containing a `manifest.json` file at root level.
- **FR-002**: System MUST support the following top-level directories: `world/`, `characters/`, `plot/`, `lore/`, `art/`, `music/`.
- **FR-003**: System MUST treat all directories and files except `manifest.json` as optional.
- **FR-004**: System MUST support Markdown (`.md`) files for prose content (setting, lore, constraints).
- **FR-005**: System MUST support JSON (`.json`) files for structured data (profiles, beats, manifest).
- **FR-006**: System MUST support common image formats (PNG, JPEG, WebP) in the `art/` directory.
- **FR-006a**: System MUST support common audio formats (MP3, OGG, WAV, FLAC) in the `music/` directory.

#### Manifest Schema

- **FR-007**: Manifest MUST include `title` (string) and `version` (semver string) fields.
- **FR-008**: Manifest SHOULD include `author`, `description`, `genre`, `tone`, and `content_rating` fields.
- **FR-009**: Manifest MAY include `rules_hint` to suggest a game mechanics style (e.g., "rules-light", "crunchy", "narrative").
- **FR-010**: Manifest MAY include `hydration_guidance` providing hints about how much the AI should invent.

#### World Definition

- **FR-011**: `world/setting.md` MUST describe the world, era, tone, and key environmental details.
- **FR-012**: `world/rules.md` MAY define custom game mechanics; if absent, default rules apply.
- **FR-013**: `world/constraints.md` MAY define absolute boundaries the AI must respect (e.g., "No resurrection", "Technology is medieval-era").

#### Character System

- **FR-014**: `characters/npcs/{name}/profile.json` MUST include `name`, `role`, and `personality` fields.
- **FR-015**: NPC profiles SHOULD include `motivations`, `relationships`, `speech_patterns`, and `secrets` fields.
- **FR-016**: `characters/npcs/{name}/portrait.png` MAY provide character artwork.
- **FR-017**: `characters/player/template.json` MAY define character creation constraints (allowed races, classes, backgrounds).

#### Plot Structure

- **FR-018**: `plot/premise.md` MUST describe the starting situation and initial hook.
- **FR-019**: `plot/beats.json` MAY define key story moments with conditions for triggering.
- **FR-020**: `plot/endings/` MAY contain multiple ending definitions as Markdown files.
- **FR-021**: Plot beats MUST include `id`, `description`, and MAY include `conditions` (trigger criteria) and `priority` fields.

#### Lore System

- **FR-022**: All files in `lore/` MUST be indexed for semantic search (RAG retrieval). Lore files MUST be chunked by paragraph (split on `\n\n`) with a maximum of 512 tokens per chunk. Token counts MUST be computed using the `tiktoken` library with the `cl100k_base` tokenizer (compatible with the sentence-transformers embedding model). If a single paragraph exceeds 512 tokens, it MUST be split on sentence boundaries (`.`, `!`, `?`).
- **FR-023**: Each lore chunk MUST be stored with metadata including: original file path, chunk index, paragraph ID, token count, and chunk method ("paragraph").
- **FR-024**: System MUST support nested directories within `lore/` for organizational flexibility.

#### Creative Assets

- **FR-025**: System MUST ingest all image files from `art/` (and nested subdirectories) with metadata linking to campaign content.
- **FR-025a**: System MUST ingest all audio files from `music/` (and nested subdirectories) with metadata linking to campaign content.
- **FR-026**: Image files MUST be supported in PNG, JPEG, and WebP formats.
- **FR-026a**: Audio files MUST be supported in MP3, OGG, WAV, and FLAC formats.
- **FR-027**: System MUST support nested directories within `art/` and `music/` for organizational flexibility (e.g., `art/characters/`, `music/ambient/`, `music/combat/`).
- **FR-028**: Asset file naming conventions SHOULD allow semantic linking (e.g., `art/characters/npc_wizard.png` indexed alongside `characters/npcs/wizard/profile.json`).

#### Ingestion Enrichment Pipeline

- **FR-032**: System MUST store asset metadata in the format `{ path: <original_file_path>, keywords: [<extracted_keywords>], generated: <boolean>, data: <content>, metadata: { created_at, source_model, version } }`.
- **FR-032a**: All ingested assets MUST include the original filesystem path to preserve campaign structure information.
- **FR-033**: When a campaign contains sparse data (fewer than 3 content files), System SHOULD invoke an on-device LLM to enrich the campaign.
- **FR-034**: Generated assets MUST be marked with `generated: true` in their metadata and stored in the campaign directory with a file extension indicating generation (e.g., `_generated.json`).
- **FR-035**: Generated assets MUST include provenance metadata: `{ source_model: "<model_name>", generated_at: "<timestamp>", version: "1.0" }`.
- **FR-036**: When a human-authored asset is added after generation, the system MUST NOT overwrite or regenerate that asset.
- **FR-037**: All generated content MUST respect the campaign format creeds: explicit `generated` marking, transparency about AI origin, and human override capability.

#### Asset Metadata Structure

All assets ingested into ObjectBox follow a consistent metadata structure to enable semantic search, provenance tracking, and relationship mapping.

**Core Metadata Schema (All Assets)**:

```json
{
  "path": "string (required)",           // Original filesystem path, e.g., "art/characters/npc_wizard.png"
  "type": "string (required)",            // Asset type: "image", "audio", "prose", "structured"
  "keywords": ["string"] (required),      // Extracted keywords for semantic search
  "generated": "boolean (required)",      // True if AI-generated, false if human-authored
  "checksum": "string (required)",        // SHA-256 hash for duplicate detection
  "created_at": "ISO8601 timestamp",      // Ingestion timestamp
  "modified_at": "ISO8601 timestamp",     // Last modification timestamp
  "data": "blob or text (required)"       // Asset content (binary for images/audio, text for prose/JSON)
}
```

**Generated Content Provenance (when `generated: true`)**:

```json
{
  "generated": true,
  "provenance": {
    "source_model": "string",            // e.g., "ollama/gemma:2b"
    "generated_at": "ISO8601 timestamp", // Generation timestamp
    "seed_data": "string",               // Original sparse data that triggered generation
    "version": "semver string"           // Campaign format version used during generation
  }
}
```

**Type-Specific Metadata**:

For `type: "image"`:
```json
{
  "image_metadata": {
    "format": "png | jpeg | webp",
    "width": "integer",
    "height": "integer",
    "alt_text": "string (optional)"     // For accessibility
  }
}
```

For `type: "audio"`:
```json
{
  "audio_metadata": {
    "format": "mp3 | ogg | wav | flac",
    "duration_seconds": "float",
    "bitrate": "integer (optional)",
    "loop": "boolean (optional)"         // For ambient music
  }
}
```

For `type: "prose"` (Markdown files):
```json
{
  "prose_metadata": {
    "word_count": "integer",
    "language": "string (ISO 639-1)",    // e.g., "en"
    "chunks": ["string"],                // Text chunks for RAG retrieval
    "chunk_method": "paragraph",         // Chunking strategy used
    "chunk_metadata": [                  // Per-chunk metadata
      {
        "chunk_id": "integer",
        "paragraph_id": "integer",
        "token_count": "integer"
      }
    ]
  }
}
```

For `type: "structured"` (JSON files):
```json
{
  "structured_metadata": {
    "schema_type": "string",             // e.g., "npc_profile", "plot_beat", "manifest"
    "schema_version": "semver string",
    "entity_id": "string (optional)"     // Extracted entity ID (e.g., NPC name)
  }
}
```

**Relationship Metadata** (for linking assets):

```json
{
  "relationships": {
    "references": ["string"],            // Paths to assets this asset references
    "referenced_by": ["string"],         // Paths to assets that reference this asset
    "entity_links": ["string"]           // Semantic entity links (e.g., "wizard", "tavern_scene")
  }
}
```

**Keyword Sidecar Files** (`.keywords.txt`)

Authors can override auto-extracted keywords by creating a sidecar file with the `.keywords.txt` extension alongside the asset:

**Example: `art/characters/npc_wizard.png.keywords.txt`**
```
# Keywords for the wizard portrait
wizard
archmage
merlin
elderly
staff
magic_user
protagonist
```

When this file exists, the system uses these keywords instead of auto-extracting from the filename or image content.

**Example: Human-Authored NPC Portrait with Sidecar Keywords**

Filesystem:
```
art/characters/npc_wizard.png
art/characters/npc_wizard.png.keywords.txt
```

Metadata in ObjectBox:
```json
{
  "path": "art/characters/npc_wizard.png",
  "type": "image",
  "keywords": ["wizard", "archmage", "merlin", "elderly", "staff", "magic_user", "protagonist"],
  "generated": false,
  "checksum": "sha256:abc123...",
  "created_at": "2026-02-03T10:30:00Z",
  "modified_at": "2026-02-03T10:30:00Z",
  "data": "<binary image data>",
  "image_metadata": {
    "format": "png",
    "width": 512,
    "height": 512,
    "alt_text": "Elderly wizard with long white beard holding a gnarled staff"
  },
  "relationships": {
    "references": [],
    "referenced_by": ["characters/npcs/wizard/profile.json"],
    "entity_links": ["wizard", "npc_merlin"]
  }
}
```

**Example: AI-Generated NPC Profile**

```json
{
  "path": "characters/npcs/baker_generated.json",
  "type": "structured",
  "keywords": ["baker", "npc", "character", "bread", "whimsical"],
  "generated": true,
  "checksum": "sha256:def456...",
  "created_at": "2026-02-03T11:00:00Z",
  "modified_at": "2026-02-03T11:00:00Z",
  "data": "{\"name\":\"Baker Breadsworth\",\"role\":\"friendly shopkeeper\",...}",
  "provenance": {
    "source_model": "ollama/qwen2.5:3b",
    "generated_at": "2026-02-03T11:00:00Z",
    "seed_data": "I am bread",
    "version": "1.0.0"
  },
  "structured_metadata": {
    "schema_type": "npc_profile",
    "schema_version": "1.0.0",
    "entity_id": "baker_breadsworth"
  },
  "relationships": {
    "references": [],
    "referenced_by": [],
    "entity_links": ["baker", "npc_baker_breadsworth"]
  }
}
```

- **FR-038**: System MUST serialize all ingested assets into ObjectBox using the core metadata schema.
- **FR-039**: System MUST extract keywords automatically from file paths, content, and metadata for semantic indexing, UNLESS a corresponding `.keywords.txt` sidecar file exists.
- **FR-039a**: When a `.keywords.txt` sidecar file exists (e.g., `npc_wizard.png.keywords.txt`), the system MUST use the keywords from that file instead of auto-extraction, respecting human-authored metadata.
- **FR-039b**: The `.keywords.txt` sidecar file format MUST be plain text with one keyword per line, allowing comments with `#` prefix.
- **FR-040**: System MUST compute and store SHA-256 checksums for all assets to enable duplicate detection.
- **FR-041**: System MUST populate `provenance` metadata for all generated assets, including source model and generation timestamp.
- **FR-042**: System SHOULD extract and store type-specific metadata (image dimensions, audio duration, word count) for enhanced retrieval.
- **FR-043**: System SHOULD build relationship graphs between assets based on file references and semantic entity links.

#### Provenance Validation (Campaign Format Creeds Enforcement)

The Campaign Format Creeds require radical transparency about AI-generated content. To enforce these creeds mechanically, the campaign ingestion layer/persistence adapter that writes to ObjectBox MUST reject assets that violate provenance requirements:

- **FR-044**: When storing an asset to ObjectBox with `generated: true`, the system MUST validate that the `provenance` object is present and contains all required fields: `source_model`, `generated_at`, and `seed_data`. If any field is missing, the campaign ingestion layer/persistence adapter MUST reject the store operation and MUST NOT write the asset to ObjectBox, returning error: "Generated asset missing provenance (generated=true requires provenance.source_model, provenance.generated_at, provenance.seed_data)".
- **FR-044a**: When storing an asset with `generated: false`, the `provenance` object MUST NOT be present (human-created assets have no provenance). If `generated: false` and `provenance` is present, the campaign ingestion layer/persistence adapter MUST reject the store operation and MUST NOT write the asset to ObjectBox, returning error: "Human-created asset must not contain provenance (generated=false conflicts with provenance object)".
- **FR-044b**: The `generated_at` timestamp in provenance MUST be a valid ISO 8601 datetime string. The campaign ingestion layer/persistence adapter MUST reject assets with non-conform timestamps and MUST NOT write them to ObjectBox.
- **FR-044c**: All generated assets ingested into ObjectBox MUST trigger a warning to authors upon campaign load: "Campaign contains [N] AI-generated asset(s). Review `generated` flags and provenance metadata to verify correctness."

> **Rationale**: These validation rules ensure the Campaign Format Creeds ("Radical Transparency", "Respect Human Artistry") are not just design guidelines but enforceable data integrity constraints. Authors cannot accidentally share campaigns with unlabeled AI content or fraudulent provenance.

#### Validation

- **FR-029**: System MUST validate campaign structure on load and report errors clearly.
- **FR-030**: System MUST validate JSON files against their schemas and report parsing errors with file paths and line numbers.
- **FR-031**: System SHOULD warn about orphaned asset references (files referenced but missing).

---

### Key Entities

- **Campaign**: A complete story package containing world, characters, plot, and lore. Identified by manifest.
- **Manifest**: Metadata describing the campaign (title, author, version, configuration hints).
- **Asset Metadata**: ObjectBox-indexed metadata wrapper containing original path, keywords, generated flag, provenance, and type-specific data for all campaign files.
- **NPC Profile**: Structured definition of a non-player character including personality, motivations, and relationships.
- **Plot Beat**: A defined story moment with optional trigger conditions and priority for the AI to work toward.
- **Constraint**: An absolute rule the AI must respect during generation (negative constraints like "no magic" or positive like "always medieval").
- **Lore Entry**: Background information indexed for semantic retrieval during play.
- **Provenance Record**: Metadata tracking for AI-generated content including source model, generation timestamp, and seed data.

---

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: A minimal campaign (manifest + setting + premise) can be loaded and played within 5 seconds of selection.
- **SC-002**: Authors can create a playable campaign with fewer than 5 files.
- **SC-003**: Campaign validation errors identify the specific file and issue within 2 seconds of load attempt.
- **SC-004**: Lore retrieval returns relevant context for 90% of narrative queries (measured by author-defined test queries).
- **SC-005**: Defined NPC dialogue is recognizably consistent with profile personality in 95% of interactions (measured by author review).
- **SC-006**: Plot beats trigger within 2 scenes of their conditions being met (when conditions are satisfiable).
- **SC-007**: Campaigns up to 100MB load without memory issues on target hardware (8GB RAM device).
- **SC-008**: Sparse data enrichment completes within 15 seconds for campaigns with 1-3 seed files on target hardware.
- **SC-009**: 100% of generated assets are marked with `generated: true` keyword in metadata.
- **SC-010**: When a human-authored asset is added after AI generation, the system correctly preserves it and does not regenerate it (tested with at least 10 generated-then-overridden assets).

---

## Assumptions

- Authors have basic familiarity with file systems and can create directories and edit text files.
- Markdown is acceptable as a prose authoring format (widely supported, human-readable).
- JSON is acceptable for structured data (widely supported, tooling available).
- ObjectBox will handle semantic indexing of all campaign content (prose, structured data, and asset metadata).
- The default rules-light system (2d6 + modifiers) is sufficient when no custom rules are provided.
- Campaign assets (art, music) are pre-made by authors; no runtime AI image or audio generation is performed.
- Asset file naming conventions follow semantic patterns that enable linking to campaign entities (e.g., `npc_wizard.png` links to NPC profiles).

---

## Dependencies

- **Spec 008: Narrative Engine** - Scene pipeline and memory system for executing campaigns.
- **Spec 006: Skill State Persistence** - For saving player progress within campaigns.
- **Spec 003: Skills Framework** - Skills that consume campaign data (narrator, choice generator, etc.).
- **On-device LLM Integration** - For sparse data enrichment (candidate models: Ollama Gemma 2B, Llama 3.2 3B, Qwen 2.5 3B per CLAUDE.md).

---

## Out of Scope

- Runtime AI image or audio generation (explicitly excluded per project research findings).
- Automatic regeneration of human-authored assets (once an author creates content, AI generation for that asset type stops).
- Multiplayer campaigns (single-player focus for initial implementation).
- Campaign marketplace or distribution system.
- Campaign versioning or migration between format versions.
- DRM or copy protection for campaigns.
- Licensing or royalty management for generated content (author discretion for sharing/distribution).

---

## Documentation Artifacts

This specification includes the following documentation artifacts for implementers and campaign authors:

### Contracts (JSON Schemas)
- **`contracts/asset-metadata.schema.json`** - ObjectBox asset metadata structure (all ingested files)
- **`contracts/manifest.schema.json`** - Campaign manifest (manifest.json)
- **`contracts/npc-profile.schema.json`** - NPC character profiles (characters/npcs/{name}/profile.json)
- **`contracts/plot-beats.schema.json`** - Plot beat definitions (plot/beats.json)
- **`contracts/player-template.schema.json`** - Player character creation template (characters/player/template.json)
- **`contracts/campaign-readme.template.md`** - Template for campaign README files

### Examples
- **`examples/minimal-campaign.md`** - Minimal 3-file campaign with AI enrichment workflow
- **`examples/complete-campaign.md`** - Fully-authored campaign with detailed structure

### Guides
- **`CAMPAIGN_AUTHOR_GUIDE.md`** - Quick reference for campaign authors
