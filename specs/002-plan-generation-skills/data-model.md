# Data Model: Plan Generation and Skill Discovery

**Purpose**: Defines the key data structures used throughout Spec 002 implementation  
**Last Updated**: 2026-01-27  
**Status**: Draft

## Overview

Narratoria's plan execution system uses the following key entities:

```
Player Input
    ↓
Plan JSON (generated by narrator AI)
    ├─ Tool (script invocation descriptor)
    │  ├─ dependencies (topological graph)
    │  ├─ retryPolicy
    │  └─ required flag
    ↓
Plan Executor
    ├─ Topological sort
    ├─ Retry logic
    ├─ Parallel/sequential dispatch
    └─ Event aggregation
    ↓
Execution Result
    └─ ToolResult[N] (full trace per tool)
    ↓
Narrator AI (replan if needed)
    └─ disabledSkills (feedback loop)
```

---

## 1. Skill Entity

A skill is a capability bundle per Agent Skills Standard.

```dart
class Skill {
  final String name;                    // e.g., "storyteller"
  final String displayName;             // e.g., "Rich Storyteller"
  final String description;             // Purpose and capabilities
  final String version;                 // Semantic version
  final String skillPath;                // Filesystem path to skill directory
  
  final String? behavioralPrompt;       // From prompt.md (injected into planner)
  final List<SkillScript> scripts;      // Executable tools
  final Map<String, ConfigField> configSchema;  // Dynamic form definition
  final Map<String, dynamic> config;    // User-provided values
  
  final bool enabled;                   // User can toggle
  final SkillErrorState errorState;     // Current health status
}

enum SkillErrorState {
  healthy,              // Available for planning
  degraded,             // Available but slow/unreliable
  temporaryFailure,     // Network timeout, retry later
  permanentFailure,     // Don't use this session
}

class SkillScript {
  final String name;                    // "narrate", "recall-memory", etc.
  final String path;                    // Filesystem path to executable
  final String language;                // "dart", "python", "rust"
  final String description;             // What this script does
}

class ConfigField {
  final String name;
  final String type;                    // "string", "number", "boolean", "enum"
  final String label;                   // For UI
  final String? hint;
  final bool sensitive;                 // Should be obscured (API keys)
  final List<String>? options;          // For enum type
  final dynamic defaultValue;
  final bool required;
}
```

---

## 2. Plan JSON (Extended)

Narrator AI generates this structure for the executor.

```dart
class PlanJson {
  final String requestId;                           // UUID for this plan
  final String narrative;                           // Fallback narration
  final List<ToolInvocation> tools;
  final bool parallel;                              // Global execution mode
  
  final List<String> disabledSkills;               // NEW: Skills to avoid this session
  final PlanMetadata metadata;
  
  // Validation methods
  bool hasCircularDependencies() { ... }
  bool isValid() { ... }
}

class ToolInvocation {
  final String toolId;                              // Unique within this plan
  final String toolPath;                            // Absolute path to executable
  final Map<String, dynamic> input;                 // Passed to script via stdin
  
  final List<String> dependencies;                  // Topological ordering
  final bool required;                              // Failure aborts dependents?
  final bool async;                                 // Can run in parallel?
  
  final RetryPolicy retryPolicy;
  
  // NEW: Gets list of tool IDs that depend on this tool
  List<String> getDependents(List<ToolInvocation> allTools) { ... }
}

class RetryPolicy {
  final int maxRetries;                             // Default: 3
  final int backoffMs;                              // Exponential backoff base
  
  Duration calculateBackoff(int attemptNumber) {
    // exponential: backoffMs * (2 ^ attemptNumber)
  }
}

class PlanMetadata {
  final int generationAttempt;                      // 1, 2, 3...
  final String? parentPlanId;                       // Previous plan UUID if replan
  final DateTime generatedAt;
}
```

---

## 3. Plan Executor State

During execution, the executor maintains:

```dart
class PlanExecutionContext {
  final PlanJson plan;
  final Map<String, ToolInvocation> toolsById;
  
  final Map<String, ToolExecutionState> executionStates;  // Per-tool tracking
  final List<LogEvent> allLogs;
  final Map<String, dynamic> aggregatedState;             // Deep-merged state patches
  
  final DateTime startTime;
  DateTime? endTime;
  
  // Lookup methods
  ToolInvocation getTool(String toolId) { ... }
  List<String> getDirectDependencies(String toolId) { ... }
  List<String> getTransitiveDependencies(String toolId) { ... }
  
  // State methods
  void markToolStarted(String toolId) { ... }
  void recordToolOutput(String toolId, ToolOutput output) { ... }
  void recordToolFailure(String toolId, String reason) { ... }
  
  // DAG operations
  List<String> topologicalSort() { ... }
  bool detectsCycle() { ... }
  List<String> getReadyTools() { ... }  // Tools with satisfied dependencies
}

enum ToolExecutionState {
  pending,          // Waiting for dependencies
  executing,        // In-flight
  completed,        // Done with ok: true
  failed,           // Done with ok: false
  skipped,          // Aborted due to dependent failure
  timeout,          // Exceeded per-tool timeout
}
```

---

## 4. Tool Execution Results

Executor collects this per-tool:

```dart
class ToolResult {
  final String toolId;
  final bool ok;                                    // Logical success from done.ok
  final ToolExecutionState state;
  
  final Duration executionTime;
  final int retryCount;
  final String? error;                              // Error message if ok=false
  
  final Map<String, dynamic> output;                // Aggregated state patches
  final List<ProtocolEvent> events;                 // All events from this tool
  
  // Derived fields for trace
  String getStatusString() { ... }
  String getSummary() { ... }
}

class ExecutionResult {
  final String planId;                              // Matches plan.requestId
  final bool success;                               // Did plan succeed overall?
  final String narrative;                           // Final narrative to display
  final Duration executionTime;
  
  final List<ToolResult> toolResults;
  final List<String> failedTools;                   // toolIds that failed
  
  final PlanMetadata generationMetadata;            // From plan
  final bool canReplan;                             // Is replanning viable?
  
  final String? failureReason;                      // Why did plan fail (if applicable)
  
  // Summary methods
  int getFailureCount() { ... }
  int getRetryCount() { ... }
  List<String> getAbortedTools() { ... }            // Tools skipped due to dependency failure
}
```

---

## 5. Protocol Events (from Spec 001)

Skill scripts emit these events; executor collects them:

```dart
sealed class ProtocolEvent {
  final String version = "0";
  final String type;
  final DateTime timestamp;
  
  factory ProtocolEvent.fromJson(Map<String, dynamic> json) {
    final type = json['type'] as String;
    return switch (type) {
      'log' => LogEvent.fromJson(json),
      'state_patch' => StatePatchEvent.fromJson(json),
      'asset' => AssetEvent.fromJson(json),
      'ui_event' => UiEvent.fromJson(json),
      'error' => ErrorEvent.fromJson(json),
      'done' => DoneEvent.fromJson(json),
      _ => throw UnknownEventTypeError(type),
    };
  }
}

class LogEvent extends ProtocolEvent {
  final String level;  // debug, info, warn, error
  final String message;
  final Map<String, dynamic>? fields;
}

class StatePatchEvent extends ProtocolEvent {
  final Map<String, dynamic> patch;
}

class AssetEvent extends ProtocolEvent {
  final String assetId;
  final String kind;           // "image", "audio", etc.
  final String mediaType;
  final String path;
  final Map<String, dynamic>? metadata;
}

class UiEvent extends ProtocolEvent {
  final String event;          // "narrative_choice", etc.
  final Map<String, dynamic>? payload;
}

class ErrorEvent extends ProtocolEvent {
  final String errorCode;
  final String errorMessage;
  final Map<String, dynamic>? details;
}

class DoneEvent extends ProtocolEvent {
  final bool ok;
  final String? summary;
}
```

---

## 6. Replan Feedback Loop

When execution fails, this data flows back to planner:

```dart
class ReplannRequest {
  final String failureReason;                       // "circular_dependency", "tool_failure", "timeout"
  final String? failedToolId;
  final String? failedSkillName;
  
  final List<String> disabledSkills;                // Don't use these skills
  final int attempt;                                // 1, 2, 3... 5
  
  final ExecutionResult previousResult;             // Full trace from last attempt
  
  // Context for planner
  String userPrompt;                                // Original player input
  SessionState currentState;                        // Accumulated world state
}

class PlannerResponse {
  final PlanJson newPlan;
  final String regenerationReason;                  // Why we regenerated
}
```

---

## 7. Session State

Accumulated from all `state_patch` events:

```dart
class SessionState {
  final Map<String, dynamic> data;                  // Arbitrary game state
  
  // Deep merge behavior from Spec 001
  void applyPatch(Map<String, dynamic> patch) {
    data.deepMerge(patch);
  }
  
  T? get<T>(String path) { ... }                    // Navigate nested paths
  void set<T>(String path, T value) { ... }
}
```

---

## 8. Execution Trace (For Debugging)

Full record of execution for logging and replay:

```dart
class ExecutionTrace {
  final String planId;
  final DateTime startTime;
  DateTime? endTime;
  
  final List<TraceEntry> entries;  // Chronological events
  
  // Entries capture:
  // - Tool started
  // - Event received (log, state_patch, ui_event, etc.)
  // - Tool completed/failed
  // - Retry attempt
  // - Dependency wait
}

class TraceEntry {
  final DateTime timestamp;
  final String type;  // "tool_started", "event_received", "tool_failed", "retry", etc.
  final String toolId;
  final Map<String, dynamic> data;  // Event or error details
}
```

---

## 9. Configuration Model

Skill configuration persisted to disk:

```dart
class ConfigPersistence {
  final String skillPath;
  
  // Loads from skills/*/config.json
  Future<Map<String, dynamic>> loadConfig() { ... }
  
  // Saves to skills/*/config.json
  Future<void> saveConfig(Map<String, dynamic> values) { ... }
  
  // Environment variable substitution: ${VAR_NAME} → value
  String resolveValue(String value) { ... }
}
```

---

## 10. Error Hierarchy

Specific exceptions for different failure modes:

```dart
abstract class NarratoriaPlanException implements Exception {
  String get message;
}

class CircularDependencyException extends NarratoriaPlanException {
  final List<String> cycle;  // e.g., ["toolA", "toolB", "toolA"]
}

class InvalidPlanJsonException extends NarratoriaPlanException {
  final String reason;  // "Missing toolId", "Unknown field", etc.
}

class ToolExecutionFailedException extends NarratoriaPlanException {
  final String toolId;
  final int attempts;
  final String reason;  // "timeout", "exit_code_1", "signal_9"
}

class DependencyFailedException extends NarratoriaPlanException {
  final String failedToolId;
  final List<String> dependentTools;
}

class PlanExecutionTimeoutException extends NarratoriaPlanException {
  final Duration timeout;
}

class SkillNotAvailableException extends NarratoriaPlanException {
  final String skillName;
  final SkillErrorState reason;
}

class MaxRetryException extends NarratoriaPlanException {
  final int maxAttempts;
  final List<String> failedTools;
}
```

---

## 11. State Merge Algorithm

Deep merge from Spec 001, formalized:

```dart
extension DeepMerge on Map<String, dynamic> {
  void deepMerge(Map<String, dynamic> patch) {
    for (final key in patch.keys) {
      final patchValue = patch[key];
      final existingValue = this[key];
      
      if (patchValue == null) {
        // Null removes the key
        remove(key);
      } else if (existingValue is Map && patchValue is Map) {
        // Recursive merge for nested objects
        (existingValue as Map<String, dynamic>)
          .deepMerge(patchValue as Map<String, dynamic>);
      } else if (existingValue is List && patchValue is List) {
        // Arrays are replaced entirely
        this[key] = patchValue;
      } else {
        // Scalar values are replaced
        this[key] = patchValue;
      }
    }
  }
}

// Example:
// existing: {"a": {"b": 1, "c": 2}, "d": [1, 2]}
// patch:    {"a": {"c": 3, "e": 4}, "d": [3]}
// result:   {"a": {"b": 1, "c": 3, "e": 4}, "d": [3]}
```

---

## UML Relationships

```
┌─────────────┐
│   Skill     │ 1..* SkillScript
├─────────────┤
│ name        │
│ scripts     │
│ config      │
│ errorState  │
└─────────────┘
      ▲
      │ uses
      │ metadata
      │
┌─────────────────────────┐
│    PlanJson             │ 1..* ToolInvocation
├─────────────────────────┤
│ requestId               │
│ tools[]                 │ ───────────────┐
│ disabledSkills[]        │                │
│ metadata                │                │
└─────────────────────────┘                │
      │                                    │
      │ input to                           │
      ▼                                    │
┌──────────────────────────────┐          │
│  PlanExecutionContext        │          │
├──────────────────────────────┤          │
│ executionStates map          │ ◄────────┤
│ aggregatedState              │          │
│ allLogs                      │ ◄────────┤ dependencies
└──────────────────────────────┘
      │
      │ produces
      ▼
┌──────────────────────────────┐
│  ExecutionResult             │ 1..* ToolResult
├──────────────────────────────┤
│ success                       │
│ toolResults[]                │
│ failedTools[]                │
│ canReplan                    │
└──────────────────────────────┘
      │
      │ feedback
      ▼
┌──────────────────────────────┐
│  ReplannRequest              │
├──────────────────────────────┤
│ failureReason                │
│ disabledSkills[]             │
│ attempt                      │
│ previousResult               │
└──────────────────────────────┘
```

---

## Type Safety and Validation

All structures validate on construction:

```dart
class PlanJson {
  PlanJson({
    required this.requestId,
    required this.narrative,
    required this.tools,
    this.parallel = false,
    this.disabledSkills = const [],
    required this.metadata,
  }) {
    if (!isValidUuid(requestId)) {
      throw InvalidPlanJsonException('Invalid requestId UUID');
    }
    if (tools.isEmpty) {
      throw InvalidPlanJsonException('tools array cannot be empty');
    }
    if (hasCircularDependencies()) {
      throw CircularDependencyException(findCycle());
    }
    // More validations...
  }
}
```

---

## Summary

This data model establishes:
- Clear separation between **plan representation** (PlanJson) and **execution state** (PlanExecutionContext)
- **Traceability**: Every event is recorded with timestamps for replay and debugging
- **Resilience**: Error states, retry policies, and feedback loops enable bounded degradation
- **Type safety**: Strong typing prevents invalid states and protocol violations
- **Composability**: Skills and tools remain independent; state is merged, not shared
